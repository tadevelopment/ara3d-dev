  
// AUTOGENERATED FILE: Do not edit directly, instead edit Structs.tt

// MIT License - Copyright (C) Ara 3D, Inc.
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

using System; 
using System.Numerics;   
namespace Ara3D  
{
	public readonly partial struct Interval : IEquatable< Interval >
	{ 
		public readonly float Min;
		public readonly float Max;
		public Interval(float min, float max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Interval x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Interval(Min = {Min}, Max = {Max})";
		public bool Equals(Interval x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Interval x0, Interval x1) => x0.Equals(x1);
		public static bool operator !=(Interval x0, Interval x1) => !x0.Equals(x1);
		public Interval SetMin(float x) => new Interval(x, Max);
		public Interval SetMax(float x) => new Interval(Min, x);
	}
	public readonly partial struct Box : IEquatable< Box >
	{ 
		public readonly Vector3 Min;
		public readonly Vector3 Max;
		public Box(Vector3 min, Vector3 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Box x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Box(Min = {Min}, Max = {Max})";
		public bool Equals(Box x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Box x0, Box x1) => x0.Equals(x1);
		public static bool operator !=(Box x0, Box x1) => !x0.Equals(x1);
		public Box SetMin(Vector3 x) => new Box(x, Max);
		public Box SetMax(Vector3 x) => new Box(Min, x);
	}
	public readonly partial struct Box2 : IEquatable< Box2 >
	{ 
		public readonly Vector2 Min;
		public readonly Vector2 Max;
		public Box2(Vector2 min, Vector2 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Box2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Box2(Min = {Min}, Max = {Max})";
		public bool Equals(Box2 x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Box2 x0, Box2 x1) => x0.Equals(x1);
		public static bool operator !=(Box2 x0, Box2 x1) => !x0.Equals(x1);
		public Box2 SetMin(Vector2 x) => new Box2(x, Max);
		public Box2 SetMax(Vector2 x) => new Box2(Min, x);
	}
	public readonly partial struct Box4 : IEquatable< Box4 >
	{ 
		public readonly Vector4 Min;
		public readonly Vector4 Max;
		public Box4(Vector4 min, Vector4 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Box4 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Box4(Min = {Min}, Max = {Max})";
		public bool Equals(Box4 x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Box4 x0, Box4 x1) => x0.Equals(x1);
		public static bool operator !=(Box4 x0, Box4 x1) => !x0.Equals(x1);
		public Box4 SetMin(Vector4 x) => new Box4(x, Max);
		public Box4 SetMax(Vector4 x) => new Box4(Min, x);
	}
	public readonly partial struct Ray : IEquatable< Ray >
	{ 
		public readonly Vector3 Position;
		public readonly Vector3 Direction;
		public Ray(Vector3 position, Vector3 direction) { Position = position; Direction = direction; }
		public override bool Equals(object obj) => obj is Ray x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
		public override string ToString() => $"Ray(Position = {Position}, Direction = {Direction})";
		public bool Equals(Ray x) => Position == x.Position && Direction == x.Direction;
		public static bool operator ==(Ray x0, Ray x1) => x0.Equals(x1);
		public static bool operator !=(Ray x0, Ray x1) => !x0.Equals(x1);
		public Ray SetPosition(Vector3 x) => new Ray(x, Direction);
		public Ray SetDirection(Vector3 x) => new Ray(Position, x);
	}
	public readonly partial struct Planed : IEquatable< Planed >
	{ 
		public readonly Vector3d Normal;
		public readonly double D;
		public Planed(Vector3d normal, double d) { Normal = normal; D = d; }
		public override bool Equals(object obj) => obj is Planed x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Normal.GetHashCode(), D.GetHashCode());
		public override string ToString() => $"Planed(Normal = {Normal}, D = {D})";
		public bool Equals(Planed x) => Normal == x.Normal && D == x.D;
		public static bool operator ==(Planed x0, Planed x1) => x0.Equals(x1);
		public static bool operator !=(Planed x0, Planed x1) => !x0.Equals(x1);
		public Planed SetNormal(Vector3d x) => new Planed(x, D);
		public Planed SetD(double x) => new Planed(Normal, x);
	}
	public readonly partial struct Sphere : IEquatable< Sphere >
	{ 
		public readonly Vector3 Center;
		public readonly float Radius;
		public Sphere(Vector3 center, float radius) { Center = center; Radius = radius; }
		public override bool Equals(object obj) => obj is Sphere x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
		public override string ToString() => $"Sphere(Center = {Center}, Radius = {Radius})";
		public bool Equals(Sphere x) => Center == x.Center && Radius == x.Radius;
		public static bool operator ==(Sphere x0, Sphere x1) => x0.Equals(x1);
		public static bool operator !=(Sphere x0, Sphere x1) => !x0.Equals(x1);
		public Sphere SetCenter(Vector3 x) => new Sphere(x, Radius);
		public Sphere SetRadius(float x) => new Sphere(Center, x);
	}
	public readonly partial struct Line : IEquatable< Line >
	{ 
		public readonly Vector3 A;
		public readonly Vector3 B;
		public Line(Vector3 a, Vector3 b) { A = a; B = b; }
		public override bool Equals(object obj) => obj is Line x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
		public override string ToString() => $"Line(A = {A}, B = {B})";
		public bool Equals(Line x) => A == x.A && B == x.B;
		public static bool operator ==(Line x0, Line x1) => x0.Equals(x1);
		public static bool operator !=(Line x0, Line x1) => !x0.Equals(x1);
		public Line SetA(Vector3 x) => new Line(x, B);
		public Line SetB(Vector3 x) => new Line(A, x);
	}
	public readonly partial struct Triangle : IEquatable< Triangle >
	{ 
		public readonly Vector3 A;
		public readonly Vector3 B;
		public readonly Vector3 C;
		public Triangle(Vector3 a, Vector3 b, Vector3 c) { A = a; B = b; C = c; }
		public override bool Equals(object obj) => obj is Triangle x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
		public override string ToString() => $"Triangle(A = {A}, B = {B}, C = {C})";
		public bool Equals(Triangle x) => A == x.A && B == x.B && C == x.C;
		public static bool operator ==(Triangle x0, Triangle x1) => x0.Equals(x1);
		public static bool operator !=(Triangle x0, Triangle x1) => !x0.Equals(x1);
		public Triangle SetA(Vector3 x) => new Triangle(x, B, C);
		public Triangle SetB(Vector3 x) => new Triangle(A, x, C);
		public Triangle SetC(Vector3 x) => new Triangle(A, B, x);
	}
	public readonly partial struct Triangle2 : IEquatable< Triangle2 >
	{ 
		public readonly Vector2 A;
		public readonly Vector2 B;
		public readonly Vector2 C;
		public Triangle2(Vector2 a, Vector2 b, Vector2 c) { A = a; B = b; C = c; }
		public override bool Equals(object obj) => obj is Triangle2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
		public override string ToString() => $"Triangle2(A = {A}, B = {B}, C = {C})";
		public bool Equals(Triangle2 x) => A == x.A && B == x.B && C == x.C;
		public static bool operator ==(Triangle2 x0, Triangle2 x1) => x0.Equals(x1);
		public static bool operator !=(Triangle2 x0, Triangle2 x1) => !x0.Equals(x1);
		public Triangle2 SetA(Vector2 x) => new Triangle2(x, B, C);
		public Triangle2 SetB(Vector2 x) => new Triangle2(A, x, C);
		public Triangle2 SetC(Vector2 x) => new Triangle2(A, B, x);
	}
	public readonly partial struct Quad : IEquatable< Quad >
	{ 
		public readonly Vector3 A;
		public readonly Vector3 B;
		public readonly Vector3 C;
		public readonly Vector3 D;
		public Quad(Vector3 a, Vector3 b, Vector3 c, Vector3 d) { A = a; B = b; C = c; D = d; }
		public override bool Equals(object obj) => obj is Quad x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
		public override string ToString() => $"Quad(A = {A}, B = {B}, C = {C}, D = {D})";
		public bool Equals(Quad x) => A == x.A && B == x.B && C == x.C && D == x.D;
		public static bool operator ==(Quad x0, Quad x1) => x0.Equals(x1);
		public static bool operator !=(Quad x0, Quad x1) => !x0.Equals(x1);
		public Quad SetA(Vector3 x) => new Quad(x, B, C, D);
		public Quad SetB(Vector3 x) => new Quad(A, x, C, D);
		public Quad SetC(Vector3 x) => new Quad(A, B, x, D);
		public Quad SetD(Vector3 x) => new Quad(A, B, C, x);
	}
	public readonly partial struct Int2 : IEquatable< Int2 >
	{ 
		public readonly int A;
		public readonly int B;
		public Int2(int a, int b) { A = a; B = b; }
		public override bool Equals(object obj) => obj is Int2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
		public override string ToString() => $"Int2(A = {A}, B = {B})";
		public bool Equals(Int2 x) => A == x.A && B == x.B;
		public static bool operator ==(Int2 x0, Int2 x1) => x0.Equals(x1);
		public static bool operator !=(Int2 x0, Int2 x1) => !x0.Equals(x1);
		public Int2 SetA(int x) => new Int2(x, B);
		public Int2 SetB(int x) => new Int2(A, x);
	}
	public readonly partial struct Int3 : IEquatable< Int3 >
	{ 
		public readonly int A;
		public readonly int B;
		public readonly int C;
		public Int3(int a, int b, int c) { A = a; B = b; C = c; }
		public override bool Equals(object obj) => obj is Int3 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
		public override string ToString() => $"Int3(A = {A}, B = {B}, C = {C})";
		public bool Equals(Int3 x) => A == x.A && B == x.B && C == x.C;
		public static bool operator ==(Int3 x0, Int3 x1) => x0.Equals(x1);
		public static bool operator !=(Int3 x0, Int3 x1) => !x0.Equals(x1);
		public Int3 SetA(int x) => new Int3(x, B, C);
		public Int3 SetB(int x) => new Int3(A, x, C);
		public Int3 SetC(int x) => new Int3(A, B, x);
	}
	public readonly partial struct Int4 : IEquatable< Int4 >
	{ 
		public readonly int A;
		public readonly int B;
		public readonly int C;
		public readonly int D;
		public Int4(int a, int b, int c, int d) { A = a; B = b; C = c; D = d; }
		public override bool Equals(object obj) => obj is Int4 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
		public override string ToString() => $"Int4(A = {A}, B = {B}, C = {C}, D = {D})";
		public bool Equals(Int4 x) => A == x.A && B == x.B && C == x.C && D == x.D;
		public static bool operator ==(Int4 x0, Int4 x1) => x0.Equals(x1);
		public static bool operator !=(Int4 x0, Int4 x1) => !x0.Equals(x1);
		public Int4 SetA(int x) => new Int4(x, B, C, D);
		public Int4 SetB(int x) => new Int4(A, x, C, D);
		public Int4 SetC(int x) => new Int4(A, B, x, D);
		public Int4 SetD(int x) => new Int4(A, B, C, x);
	}
	public readonly partial struct Vector3d : IEquatable< Vector3d >
	{ 
		public readonly double X;
		public readonly double Y;
		public readonly double Z;
		public Vector3d(double x, double y, double z) { X = x; Y = y; Z = z; }
		public override bool Equals(object obj) => obj is Vector3d x && Equals(x);
		public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
		public override string ToString() => $"Vector3d(X = {X}, Y = {Y}, Z = {Z})";
		public bool Equals(Vector3d x) => X == x.X && Y == x.Y && Z == x.Z;
		public static bool operator ==(Vector3d x0, Vector3d x1) => x0.Equals(x1);
		public static bool operator !=(Vector3d x0, Vector3d x1) => !x0.Equals(x1);
		public Vector3d SetX(double x) => new Vector3d(x, Y, Z);
		public Vector3d SetY(double x) => new Vector3d(X, x, Z);
		public Vector3d SetZ(double x) => new Vector3d(X, Y, x);
	}
	public readonly partial struct Quaterniond : IEquatable< Quaterniond >
	{ 
		public readonly double X;
		public readonly double Y;
		public readonly double Z;
		public readonly double W;
		public Quaterniond(double x, double y, double z, double w) { X = x; Y = y; Z = z; W = w; }
		public override bool Equals(object obj) => obj is Quaterniond x && Equals(x);
		public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
		public override string ToString() => $"Quaterniond(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
		public bool Equals(Quaterniond x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
		public static bool operator ==(Quaterniond x0, Quaterniond x1) => x0.Equals(x1);
		public static bool operator !=(Quaterniond x0, Quaterniond x1) => !x0.Equals(x1);
		public Quaterniond SetX(double x) => new Quaterniond(x, Y, Z, W);
		public Quaterniond SetY(double x) => new Quaterniond(X, x, Z, W);
		public Quaterniond SetZ(double x) => new Quaterniond(X, Y, x, W);
		public Quaterniond SetW(double x) => new Quaterniond(X, Y, Z, x);
	}
}