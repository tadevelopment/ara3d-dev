  
// AUTOGENERATED FILE: Do not edit directly, instead edit Structs.tt

// MIT License - Copyright (C) Ara 3D, Inc.
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

using System; 
using System.Numerics;   
namespace Ara3D  
{
	public readonly partial struct DVector2 : IEquatable< DVector2 >
	{ 
		public readonly double X;
		public readonly double Y;
		public DVector2(double x, double y) { X = x; Y = y; }
		public override bool Equals(object obj) => obj is DVector2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode());
		public override string ToString() => $"DVector2(X = {X}, Y = {Y})";
		public bool Equals(DVector2 x) => X == x.X && Y == x.Y;
		public static bool operator ==(DVector2 x0, DVector2 x1) => x0.Equals(x1);
		public static bool operator !=(DVector2 x0, DVector2 x1) => !x0.Equals(x1);
		public DVector2 SetX(double x) => new DVector2(x, Y);
		public DVector2 SetY(double x) => new DVector2(X, x);
	}
	public readonly partial struct DVector3 : IEquatable< DVector3 >
	{ 
		public readonly double X;
		public readonly double Y;
		public readonly double Z;
		public DVector3(double x, double y, double z) { X = x; Y = y; Z = z; }
		public override bool Equals(object obj) => obj is DVector3 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode());
		public override string ToString() => $"DVector3(X = {X}, Y = {Y}, Z = {Z})";
		public bool Equals(DVector3 x) => X == x.X && Y == x.Y && Z == x.Z;
		public static bool operator ==(DVector3 x0, DVector3 x1) => x0.Equals(x1);
		public static bool operator !=(DVector3 x0, DVector3 x1) => !x0.Equals(x1);
		public DVector3 SetX(double x) => new DVector3(x, Y, Z);
		public DVector3 SetY(double x) => new DVector3(X, x, Z);
		public DVector3 SetZ(double x) => new DVector3(X, Y, x);
	}
	public readonly partial struct DVector4 : IEquatable< DVector4 >
	{ 
		public readonly double X;
		public readonly double Y;
		public readonly double Z;
		public readonly double W;
		public DVector4(double x, double y, double z, double w) { X = x; Y = y; Z = z; W = w; }
		public override bool Equals(object obj) => obj is DVector4 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
		public override string ToString() => $"DVector4(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
		public bool Equals(DVector4 x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
		public static bool operator ==(DVector4 x0, DVector4 x1) => x0.Equals(x1);
		public static bool operator !=(DVector4 x0, DVector4 x1) => !x0.Equals(x1);
		public DVector4 SetX(double x) => new DVector4(x, Y, Z, W);
		public DVector4 SetY(double x) => new DVector4(X, x, Z, W);
		public DVector4 SetZ(double x) => new DVector4(X, Y, x, W);
		public DVector4 SetW(double x) => new DVector4(X, Y, Z, x);
	}
	public readonly partial struct DQuaternion : IEquatable< DQuaternion >
	{ 
		public readonly double X;
		public readonly double Y;
		public readonly double Z;
		public readonly double W;
		public DQuaternion(double x, double y, double z, double w) { X = x; Y = y; Z = z; W = w; }
		public override bool Equals(object obj) => obj is DQuaternion x && Equals(x);
		public override int GetHashCode() => Hash.Combine(X.GetHashCode(), Y.GetHashCode(), Z.GetHashCode(), W.GetHashCode());
		public override string ToString() => $"DQuaternion(X = {X}, Y = {Y}, Z = {Z}, W = {W})";
		public bool Equals(DQuaternion x) => X == x.X && Y == x.Y && Z == x.Z && W == x.W;
		public static bool operator ==(DQuaternion x0, DQuaternion x1) => x0.Equals(x1);
		public static bool operator !=(DQuaternion x0, DQuaternion x1) => !x0.Equals(x1);
		public DQuaternion SetX(double x) => new DQuaternion(x, Y, Z, W);
		public DQuaternion SetY(double x) => new DQuaternion(X, x, Z, W);
		public DQuaternion SetZ(double x) => new DQuaternion(X, Y, x, W);
		public DQuaternion SetW(double x) => new DQuaternion(X, Y, Z, x);
	}
	public readonly partial struct DPlane : IEquatable< DPlane >
	{ 
		public readonly DVector3 Normal;
		public readonly double D;
		public DPlane(DVector3 normal, double d) { Normal = normal; D = d; }
		public override bool Equals(object obj) => obj is DPlane x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Normal.GetHashCode(), D.GetHashCode());
		public override string ToString() => $"DPlane(Normal = {Normal}, D = {D})";
		public bool Equals(DPlane x) => Normal == x.Normal && D == x.D;
		public static bool operator ==(DPlane x0, DPlane x1) => x0.Equals(x1);
		public static bool operator !=(DPlane x0, DPlane x1) => !x0.Equals(x1);
		public DPlane SetNormal(DVector3 x) => new DPlane(x, D);
		public DPlane SetD(double x) => new DPlane(Normal, x);
	}
	public readonly partial struct Interval : IEquatable< Interval >
	{ 
		public readonly float Min;
		public readonly float Max;
		public Interval(float min, float max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Interval x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Interval(Min = {Min}, Max = {Max})";
		public bool Equals(Interval x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Interval x0, Interval x1) => x0.Equals(x1);
		public static bool operator !=(Interval x0, Interval x1) => !x0.Equals(x1);
		public Interval SetMin(float x) => new Interval(x, Max);
		public Interval SetMax(float x) => new Interval(Min, x);
	}
	public readonly partial struct Box2 : IEquatable< Box2 >
	{ 
		public readonly Vector2 Min;
		public readonly Vector2 Max;
		public Box2(Vector2 min, Vector2 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Box2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Box2(Min = {Min}, Max = {Max})";
		public bool Equals(Box2 x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Box2 x0, Box2 x1) => x0.Equals(x1);
		public static bool operator !=(Box2 x0, Box2 x1) => !x0.Equals(x1);
		public Box2 SetMin(Vector2 x) => new Box2(x, Max);
		public Box2 SetMax(Vector2 x) => new Box2(Min, x);
	}
	public readonly partial struct Box : IEquatable< Box >
	{ 
		public readonly Vector3 Min;
		public readonly Vector3 Max;
		public Box(Vector3 min, Vector3 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Box x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Box(Min = {Min}, Max = {Max})";
		public bool Equals(Box x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Box x0, Box x1) => x0.Equals(x1);
		public static bool operator !=(Box x0, Box x1) => !x0.Equals(x1);
		public Box SetMin(Vector3 x) => new Box(x, Max);
		public Box SetMax(Vector3 x) => new Box(Min, x);
	}
	public readonly partial struct Box4 : IEquatable< Box4 >
	{ 
		public readonly Vector4 Min;
		public readonly Vector4 Max;
		public Box4(Vector4 min, Vector4 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is Box4 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"Box4(Min = {Min}, Max = {Max})";
		public bool Equals(Box4 x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(Box4 x0, Box4 x1) => x0.Equals(x1);
		public static bool operator !=(Box4 x0, Box4 x1) => !x0.Equals(x1);
		public Box4 SetMin(Vector4 x) => new Box4(x, Max);
		public Box4 SetMax(Vector4 x) => new Box4(Min, x);
	}
	public readonly partial struct DInterval : IEquatable< DInterval >
	{ 
		public readonly double Min;
		public readonly double Max;
		public DInterval(double min, double max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is DInterval x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"DInterval(Min = {Min}, Max = {Max})";
		public bool Equals(DInterval x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(DInterval x0, DInterval x1) => x0.Equals(x1);
		public static bool operator !=(DInterval x0, DInterval x1) => !x0.Equals(x1);
		public DInterval SetMin(double x) => new DInterval(x, Max);
		public DInterval SetMax(double x) => new DInterval(Min, x);
	}
	public readonly partial struct DBox2 : IEquatable< DBox2 >
	{ 
		public readonly DVector2 Min;
		public readonly DVector2 Max;
		public DBox2(DVector2 min, DVector2 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is DBox2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"DBox2(Min = {Min}, Max = {Max})";
		public bool Equals(DBox2 x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(DBox2 x0, DBox2 x1) => x0.Equals(x1);
		public static bool operator !=(DBox2 x0, DBox2 x1) => !x0.Equals(x1);
		public DBox2 SetMin(DVector2 x) => new DBox2(x, Max);
		public DBox2 SetMax(DVector2 x) => new DBox2(Min, x);
	}
	public readonly partial struct DBox3 : IEquatable< DBox3 >
	{ 
		public readonly DVector3 Min;
		public readonly DVector3 Max;
		public DBox3(DVector3 min, DVector3 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is DBox3 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"DBox3(Min = {Min}, Max = {Max})";
		public bool Equals(DBox3 x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(DBox3 x0, DBox3 x1) => x0.Equals(x1);
		public static bool operator !=(DBox3 x0, DBox3 x1) => !x0.Equals(x1);
		public DBox3 SetMin(DVector3 x) => new DBox3(x, Max);
		public DBox3 SetMax(DVector3 x) => new DBox3(Min, x);
	}
	public readonly partial struct DBox4 : IEquatable< DBox4 >
	{ 
		public readonly DVector4 Min;
		public readonly DVector4 Max;
		public DBox4(DVector4 min, DVector4 max) { Min = min; Max = max; }
		public override bool Equals(object obj) => obj is DBox4 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Min.GetHashCode(), Max.GetHashCode());
		public override string ToString() => $"DBox4(Min = {Min}, Max = {Max})";
		public bool Equals(DBox4 x) => Min == x.Min && Max == x.Max;
		public static bool operator ==(DBox4 x0, DBox4 x1) => x0.Equals(x1);
		public static bool operator !=(DBox4 x0, DBox4 x1) => !x0.Equals(x1);
		public DBox4 SetMin(DVector4 x) => new DBox4(x, Max);
		public DBox4 SetMax(DVector4 x) => new DBox4(Min, x);
	}
	public readonly partial struct Ray : IEquatable< Ray >
	{ 
		public readonly Vector3 Position;
		public readonly Vector3 Direction;
		public Ray(Vector3 position, Vector3 direction) { Position = position; Direction = direction; }
		public override bool Equals(object obj) => obj is Ray x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
		public override string ToString() => $"Ray(Position = {Position}, Direction = {Direction})";
		public bool Equals(Ray x) => Position == x.Position && Direction == x.Direction;
		public static bool operator ==(Ray x0, Ray x1) => x0.Equals(x1);
		public static bool operator !=(Ray x0, Ray x1) => !x0.Equals(x1);
		public Ray SetPosition(Vector3 x) => new Ray(x, Direction);
		public Ray SetDirection(Vector3 x) => new Ray(Position, x);
	}
	public readonly partial struct DRay : IEquatable< DRay >
	{ 
		public readonly DVector3 Position;
		public readonly DVector3 Direction;
		public DRay(DVector3 position, DVector3 direction) { Position = position; Direction = direction; }
		public override bool Equals(object obj) => obj is DRay x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Position.GetHashCode(), Direction.GetHashCode());
		public override string ToString() => $"DRay(Position = {Position}, Direction = {Direction})";
		public bool Equals(DRay x) => Position == x.Position && Direction == x.Direction;
		public static bool operator ==(DRay x0, DRay x1) => x0.Equals(x1);
		public static bool operator !=(DRay x0, DRay x1) => !x0.Equals(x1);
		public DRay SetPosition(DVector3 x) => new DRay(x, Direction);
		public DRay SetDirection(DVector3 x) => new DRay(Position, x);
	}
	public readonly partial struct Sphere : IEquatable< Sphere >
	{ 
		public readonly Vector3 Center;
		public readonly float Radius;
		public Sphere(Vector3 center, float radius) { Center = center; Radius = radius; }
		public override bool Equals(object obj) => obj is Sphere x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
		public override string ToString() => $"Sphere(Center = {Center}, Radius = {Radius})";
		public bool Equals(Sphere x) => Center == x.Center && Radius == x.Radius;
		public static bool operator ==(Sphere x0, Sphere x1) => x0.Equals(x1);
		public static bool operator !=(Sphere x0, Sphere x1) => !x0.Equals(x1);
		public Sphere SetCenter(Vector3 x) => new Sphere(x, Radius);
		public Sphere SetRadius(float x) => new Sphere(Center, x);
	}
	public readonly partial struct DSphere : IEquatable< DSphere >
	{ 
		public readonly DVector3 Center;
		public readonly double Radius;
		public DSphere(DVector3 center, double radius) { Center = center; Radius = radius; }
		public override bool Equals(object obj) => obj is DSphere x && Equals(x);
		public override int GetHashCode() => Hash.Combine(Center.GetHashCode(), Radius.GetHashCode());
		public override string ToString() => $"DSphere(Center = {Center}, Radius = {Radius})";
		public bool Equals(DSphere x) => Center == x.Center && Radius == x.Radius;
		public static bool operator ==(DSphere x0, DSphere x1) => x0.Equals(x1);
		public static bool operator !=(DSphere x0, DSphere x1) => !x0.Equals(x1);
		public DSphere SetCenter(DVector3 x) => new DSphere(x, Radius);
		public DSphere SetRadius(double x) => new DSphere(Center, x);
	}
	public readonly partial struct Line : IEquatable< Line >
	{ 
		public readonly Vector3 A;
		public readonly Vector3 B;
		public Line(Vector3 a, Vector3 b) { A = a; B = b; }
		public override bool Equals(object obj) => obj is Line x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
		public override string ToString() => $"Line(A = {A}, B = {B})";
		public bool Equals(Line x) => A == x.A && B == x.B;
		public static bool operator ==(Line x0, Line x1) => x0.Equals(x1);
		public static bool operator !=(Line x0, Line x1) => !x0.Equals(x1);
		public Line SetA(Vector3 x) => new Line(x, B);
		public Line SetB(Vector3 x) => new Line(A, x);
	}
	public readonly partial struct Triangle : IEquatable< Triangle >
	{ 
		public readonly Vector3 A;
		public readonly Vector3 B;
		public readonly Vector3 C;
		public Triangle(Vector3 a, Vector3 b, Vector3 c) { A = a; B = b; C = c; }
		public override bool Equals(object obj) => obj is Triangle x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
		public override string ToString() => $"Triangle(A = {A}, B = {B}, C = {C})";
		public bool Equals(Triangle x) => A == x.A && B == x.B && C == x.C;
		public static bool operator ==(Triangle x0, Triangle x1) => x0.Equals(x1);
		public static bool operator !=(Triangle x0, Triangle x1) => !x0.Equals(x1);
		public Triangle SetA(Vector3 x) => new Triangle(x, B, C);
		public Triangle SetB(Vector3 x) => new Triangle(A, x, C);
		public Triangle SetC(Vector3 x) => new Triangle(A, B, x);
	}
	public readonly partial struct Triangle2 : IEquatable< Triangle2 >
	{ 
		public readonly Vector2 A;
		public readonly Vector2 B;
		public readonly Vector2 C;
		public Triangle2(Vector2 a, Vector2 b, Vector2 c) { A = a; B = b; C = c; }
		public override bool Equals(object obj) => obj is Triangle2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
		public override string ToString() => $"Triangle2(A = {A}, B = {B}, C = {C})";
		public bool Equals(Triangle2 x) => A == x.A && B == x.B && C == x.C;
		public static bool operator ==(Triangle2 x0, Triangle2 x1) => x0.Equals(x1);
		public static bool operator !=(Triangle2 x0, Triangle2 x1) => !x0.Equals(x1);
		public Triangle2 SetA(Vector2 x) => new Triangle2(x, B, C);
		public Triangle2 SetB(Vector2 x) => new Triangle2(A, x, C);
		public Triangle2 SetC(Vector2 x) => new Triangle2(A, B, x);
	}
	public readonly partial struct Quad : IEquatable< Quad >
	{ 
		public readonly Vector3 A;
		public readonly Vector3 B;
		public readonly Vector3 C;
		public readonly Vector3 D;
		public Quad(Vector3 a, Vector3 b, Vector3 c, Vector3 d) { A = a; B = b; C = c; D = d; }
		public override bool Equals(object obj) => obj is Quad x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
		public override string ToString() => $"Quad(A = {A}, B = {B}, C = {C}, D = {D})";
		public bool Equals(Quad x) => A == x.A && B == x.B && C == x.C && D == x.D;
		public static bool operator ==(Quad x0, Quad x1) => x0.Equals(x1);
		public static bool operator !=(Quad x0, Quad x1) => !x0.Equals(x1);
		public Quad SetA(Vector3 x) => new Quad(x, B, C, D);
		public Quad SetB(Vector3 x) => new Quad(A, x, C, D);
		public Quad SetC(Vector3 x) => new Quad(A, B, x, D);
		public Quad SetD(Vector3 x) => new Quad(A, B, C, x);
	}
	public readonly partial struct Int2 : IEquatable< Int2 >
	{ 
		public readonly int A;
		public readonly int B;
		public Int2(int a, int b) { A = a; B = b; }
		public override bool Equals(object obj) => obj is Int2 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode());
		public override string ToString() => $"Int2(A = {A}, B = {B})";
		public bool Equals(Int2 x) => A == x.A && B == x.B;
		public static bool operator ==(Int2 x0, Int2 x1) => x0.Equals(x1);
		public static bool operator !=(Int2 x0, Int2 x1) => !x0.Equals(x1);
		public Int2 SetA(int x) => new Int2(x, B);
		public Int2 SetB(int x) => new Int2(A, x);
	}
	public readonly partial struct Int3 : IEquatable< Int3 >
	{ 
		public readonly int A;
		public readonly int B;
		public readonly int C;
		public Int3(int a, int b, int c) { A = a; B = b; C = c; }
		public override bool Equals(object obj) => obj is Int3 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode());
		public override string ToString() => $"Int3(A = {A}, B = {B}, C = {C})";
		public bool Equals(Int3 x) => A == x.A && B == x.B && C == x.C;
		public static bool operator ==(Int3 x0, Int3 x1) => x0.Equals(x1);
		public static bool operator !=(Int3 x0, Int3 x1) => !x0.Equals(x1);
		public Int3 SetA(int x) => new Int3(x, B, C);
		public Int3 SetB(int x) => new Int3(A, x, C);
		public Int3 SetC(int x) => new Int3(A, B, x);
	}
	public readonly partial struct Int4 : IEquatable< Int4 >
	{ 
		public readonly int A;
		public readonly int B;
		public readonly int C;
		public readonly int D;
		public Int4(int a, int b, int c, int d) { A = a; B = b; C = c; D = d; }
		public override bool Equals(object obj) => obj is Int4 x && Equals(x);
		public override int GetHashCode() => Hash.Combine(A.GetHashCode(), B.GetHashCode(), C.GetHashCode(), D.GetHashCode());
		public override string ToString() => $"Int4(A = {A}, B = {B}, C = {C}, D = {D})";
		public bool Equals(Int4 x) => A == x.A && B == x.B && C == x.C && D == x.D;
		public static bool operator ==(Int4 x0, Int4 x1) => x0.Equals(x1);
		public static bool operator !=(Int4 x0, Int4 x1) => !x0.Equals(x1);
		public Int4 SetA(int x) => new Int4(x, B, C, D);
		public Int4 SetB(int x) => new Int4(A, x, C, D);
		public Int4 SetC(int x) => new Int4(A, B, x, D);
		public Int4 SetD(int x) => new Int4(A, B, C, x);
	}
}